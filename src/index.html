<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>延迟对象</title>
  <link rel="stylesheet" href="css/reset.css">
  <style>
    .box {
      width: 100px;
      height: 100px;
      background: red;
    }
  </style>
</head>

<body>
  <div class="box"></div>

  <script src="js/jquery.js">
  </script>
  <script>
    // 让异步代码扁平化，脱离回调地狱, 提供异步函数链式操作
    console.log(1);


    setTimeout(function () {
      console.log(3);
    }, 0)

    console.log(2);

    // $('.box').animate({width:200},function(){
    //   $('.box').animate({height:200},function(){
    //     $('.box').animate({marginTop:200},function(){
    //       $('.box').animate({marginLeft:200},function(){

    //       })
    //     })
    //   })
    // });


    // 延迟对象优化以上代码
    function animate(option) {

      var de = $.Deferred();
      $('.box').animate(option, function () {
        de.resolve();
        // Callbacks.fire()
      });
      return de;
    }
    // done  resolve   reject always fail
    animate({
      width: 200
    }).then(function () {
      return animate({height: 200});
    }).then(function(){
      return animate({ marginTop:100})
    }).then(function(){
      return animate({ marginLeft:300})
    })


    function Sleep(time){
      var def = $.Deferred();

      setTimeout(function(){
        def.resolve();
      },time)

      return def;
    }
    // Deferred 最直观的价值，控制异步的触发顺序，并且使代码的阅读性提高
    Sleep(1000)
    .then(function(){
      console.log('第一次触发');
      return Sleep(2000);
    })
    .then(function(){
      console.log('第二次触发');
    })


    // Callbacks  [resolve fn fn fn]
  </script>
</body>

</html>